<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>MBSTOI API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>MBSTOI</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/__init__.py#L0-L25" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from MBSTOI.stft import stft
from MBSTOI.thirdoct import thirdoct
from MBSTOI.remove_silent_frames import remove_silent_frames
from MBSTOI.mbstoi import mbstoi
from MBSTOI.mbstoiplus import mbstoiplus
from MBSTOI.mbstoi_noEC import mbstoi_noEC
from MBSTOI.ec import ec
from MBSTOI.ecplus import ecplus, dsfactor, sosfilter, get_itds_ilds
from MBSTOI.mparametricild import mparametricild

__all__ = [
    &#34;stft&#34;,
    &#34;thirdoct&#34;,
    &#34;remove_silent_frames&#34;,
    &#34;mbstoi&#34;,
    &#34;mbstoiplus&#34;,
    &#34;mbstoi_noEC&#34;,
    &#34;mparametricild&#34;,
    &#34;ec&#34;,
    &#34;ecplus&#34;,
    &#34;dsfactor&#34;,
    &#34;sosfilter&#34;,
    &#34;get_itds_ilds&#34;,
]

MASTER_FS = 44100</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MBSTOI.dsfactor"><code class="name flex">
<span>def <span class="ident">dsfactor</span></span>(<span>freq, fs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/ecplus.py#L372-L376" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dsfactor(freq, fs):
    factor = (np.floor((fs / 2.10) / np.array(freq))).astype(&#34;int&#34;)
    for idx in range(len(factor)):
        factor[idx] = max(min(factor[idx], 50), 1)
    return factor</code></pre>
</details>
</dd>
<dt id="MBSTOI.ec"><code class="name flex">
<span>def <span class="ident">ec</span></span>(<span>xl_hat, xr_hat, yl_hat, yr_hat, J, N, fids, cf, taus, ntaus, gammas, ngammas, d, p_ec_max, sigma_epsilon, sigma_delta)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the equalisation-cancellation (EC) stage of the MBSTOI metric.
The EC loop evaluates one huge equation in every iteration.
See referenced notes for details.
The left and right ear signals are level adjusted by gamma (in dB) and time
shifted by tau relative to one-another and are thereafter subtracted.
The processed signals are treated similarly.
To obtain performance similar to that of humans,the EC stage adds jitter
We are searching for the level and time adjustments that maximise the
intermediate correlation coefficients d.
Will add location of source and interferer to this to reduce search space.</p>
<h2 id="args">Args</h2>
<dl>
<dt>xl_hat(ndarray): clean L short-time DFT coefficients (single-sided) per frequency bin and frame</dt>
<dt>xr_hat(ndarray): clean R short-time DFT coefficients (single-sided) per frequency bin and frame</dt>
<dt>yl_hat(ndarray): proc. L short-time DFT coefficients (single-sided) per frequency bin and frame</dt>
<dt>yr_hat(ndarray): proc. R short-time DFT coefficients (single-sided) per frequency bin and frame</dt>
<dt><strong><code>J</code></strong> :&ensp;<code>int</code></dt>
<dd>number of one-third octave bands</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>number of frames for intermediate intelligibility measure</dd>
<dt><strong><code>fids</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>indices of frequency band edges</dd>
<dt><strong><code>cf</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>centre frequencies</dd>
<dt><strong><code>taus</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>interaural delay (tau) values</dd>
<dt><strong><code>ntaus</code></strong> :&ensp;<code>int</code></dt>
<dd>number tau values</dd>
<dt><strong><code>gammas</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>interaural level difference (gamma) values</dd>
<dt><strong><code>ngammas</code></strong> :&ensp;<code>int</code></dt>
<dd>number gamma values</dd>
<dt><strong><code>d</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>grid for intermediate intelligibility measure</dd>
<dt><strong><code>p_ec_max</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>empty grid for maximum values</dd>
<dt><strong><code>sigma_epsilon</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>jitter for gammas</dd>
<dt><strong><code>sigma_delta</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>jitter for taus</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>d (ndarray): updated grid for intermediate intelligibility measure
p_ec_max (ndarray): grid containing maximum values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/ec.py#L6-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ec(
    xl_hat,
    xr_hat,
    yl_hat,
    yr_hat,
    J,
    N,
    fids,
    cf,
    taus,
    ntaus,
    gammas,
    ngammas,
    d,
    p_ec_max,
    sigma_epsilon,
    sigma_delta,
):
    &#34;&#34;&#34;Run the equalisation-cancellation (EC) stage of the MBSTOI metric.
    The EC loop evaluates one huge equation in every iteration.
    See referenced notes for details.
    The left and right ear signals are level adjusted by gamma (in dB) and time
    shifted by tau relative to one-another and are thereafter subtracted.
    The processed signals are treated similarly.
    To obtain performance similar to that of humans,the EC stage adds jitter
    We are searching for the level and time adjustments that maximise the
    intermediate correlation coefficients d.
    Will add location of source and interferer to this to reduce search space.
    Args:
        xl_hat(ndarray): clean L short-time DFT coefficients (single-sided) per frequency bin and frame
        xr_hat(ndarray): clean R short-time DFT coefficients (single-sided) per frequency bin and frame
        yl_hat(ndarray): proc. L short-time DFT coefficients (single-sided) per frequency bin and frame
        yr_hat(ndarray): proc. R short-time DFT coefficients (single-sided) per frequency bin and frame
        J (int): number of one-third octave bands
        N (int): number of frames for intermediate intelligibility measure
        fids (ndarray): indices of frequency band edges
        cf (ndarray): centre frequencies
        taus (ndarray): interaural delay (tau) values
        ntaus (int): number tau values
        gammas (ndarray): interaural level difference (gamma) values
        ngammas (int): number gamma values
        d (ndarray): grid for intermediate intelligibility measure
        p_ec_max (ndarray): empty grid for maximum values
        sigma_epsilon (ndarray): jitter for gammas
        sigma_delta (ndarray): jitter for taus
    Returns:
        d (ndarray): updated grid for intermediate intelligibility measure
        p_ec_max (ndarray): grid containing maximum values
    &#34;&#34;&#34;

    taus = np.expand_dims(taus, axis=0)
    sigma_delta = np.expand_dims(sigma_delta, axis=0)
    sigma_epsilon = np.expand_dims(sigma_epsilon, axis=0)
    gammas = np.expand_dims(gammas, axis=0)
    epsexp = np.exp(2 * np.log(10) ** 2 * sigma_epsilon ** 2)

    for i in range(J):  # per frequency band
        tauexp = np.exp(-1j * cf[i] * taus)
        tauexp2 = np.exp(-1j * 2 * cf[i] * taus)
        deltexp = np.exp(-2 * cf[i] ** 2 * sigma_delta ** 2)
        epsdelexp = np.exp(
            0.5
            * (
                np.ones((ntaus, 1))
                * (
                    np.log(10) ** 2 * sigma_epsilon ** 2
                    - cf[i] ** 2 * np.transpose(sigma_delta) ** 2
                )
                * np.ones((1, ngammas))
            )
        )

        for jj in range(np.shape(d)[1]):  # per frame
            seg_xl = xl_hat[int(fids[i, 0] - 1) : int(fids[i, 1]), jj : (jj + N)]
            seg_xr = xr_hat[int(fids[i, 0] - 1) : int(fids[i, 1]), jj : (jj + N)]
            seg_yl = yl_hat[int(fids[i, 0] - 1) : int(fids[i, 1]), jj : (jj + N)]
            seg_yr = yr_hat[int(fids[i, 0] - 1) : int(fids[i, 1]), jj : (jj + N)]

            # All normalised by subtracting mean
            Lx = np.sum(np.conj(seg_xl) * seg_xl, axis=0)
            Lx = np.expand_dims(Lx, axis=0)
            Lx = Lx - np.mean(Lx)
            Rx = np.sum(np.conj(seg_xr) * seg_xr, axis=0)
            Rx = np.expand_dims(Rx, axis=0)
            Rx = Rx - np.mean(Rx)
            rhox = np.sum(np.conj(seg_xr) * seg_xl, axis=0)
            rhox = np.expand_dims(rhox, axis=0)
            rhox = rhox - np.mean(rhox)
            Ly = np.sum(np.conj(seg_yl) * seg_yl, axis=0)
            Ly = np.expand_dims(Ly, axis=0)
            Ly = Ly - np.mean(Ly)
            Ry = np.sum(np.conj(seg_yr) * seg_yr, axis=0)
            Ry = np.expand_dims(Ry, axis=0)
            Ry = Ry - np.mean(Ry)
            rhoy = np.sum(np.conj(seg_yr) * seg_yl, axis=0)
            rhoy = np.expand_dims(rhoy, axis=0)
            rhoy = rhoy - np.mean(rhoy)

            # Evaluate parts of intermediate correlation - EC stage exhaustive search over ITD/ILD values
            # These correspond to equations 7 and 8 in Andersen et al. 2018
            # Calculate Exy
            firstpart = firstpartfunc(Lx, Ly, Rx, Ry, ntaus, gammas, epsexp)
            secondpart = secondpartfunc(Lx, Ly, rhoy, rhox, tauexp, epsdelexp, gammas)
            thirdpart = thirdpartfunc(Rx, Ry, rhoy, rhox, tauexp, epsdelexp, gammas)
            fourthpart = fourthpartfunc(rhox, rhoy, tauexp2, ngammas, deltexp)
            exy = firstpart - secondpart - thirdpart + fourthpart

            # Calculate Exx
            firstpart = firstpartfunc(Lx, Lx, Rx, Rx, ntaus, gammas, epsexp)
            secondpart = secondpartfunc(Lx, Lx, rhox, rhox, tauexp, epsdelexp, gammas)
            thirdpart = thirdpartfunc(Rx, Rx, rhox, rhox, tauexp, epsdelexp, gammas)
            fourthpart = fourthpartfunc(rhox, rhox, tauexp2, ngammas, deltexp)
            exx = firstpart - secondpart - thirdpart + fourthpart

            # Calculate Eyy
            firstpart = firstpartfunc(Ly, Ly, Ry, Ry, ntaus, gammas, epsexp)
            secondpart = secondpartfunc(Ly, Ly, rhoy, rhoy, tauexp, epsdelexp, gammas)
            thirdpart = thirdpartfunc(Ry, Ry, rhoy, rhoy, tauexp, epsdelexp, gammas)
            fourthpart = fourthpartfunc(rhoy, rhoy, tauexp2, ngammas, deltexp)
            eyy = firstpart - secondpart - thirdpart + fourthpart

            # Ensure that intermediate correlation will be sensible and compute it
            if np.min(abs(exx * eyy)) &lt; 1e-40:
                d[i, jj] = -1
                continue
            else:
                p = np.divide(exx, eyy)
                tmp = p.max(axis=0)
                idx1 = p.argmax(axis=0)

                # Return overall maximum and index
                p_ec_max[i, jj] = tmp.max(axis=0)
                idx2 = tmp.argmax(axis=0)

                d[i, jj] = np.divide(
                    exy[idx1[idx2], idx2],
                    np.sqrt(exx[idx1[idx2], idx2] * eyy[idx1[idx2], idx2]),
                )

    return d, p_ec_max</code></pre>
</details>
</dd>
<dt id="MBSTOI.ecplus"><code class="name flex">
<span>def <span class="ident">ecplus</span></span>(<span>scene, hrirs_input_path, xl_hat, xr_hat, yl_hat, yr_hat, J, N, fids, cf, ntaus, ngammas)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the equalisation-cancellation (EC) stage of the MBSTOI metric.
The EC loop evaluates one huge equation in every iteration.
See referenced notes for details.
The left and right ear signals are level adjusted by gamma (in dB) and time
shifted by tau relative to one-another and are thereafter subtracted.
The processed signals are treated similarly.
To obtain performance similar to that of humans,the EC stage adds jitter
We are searching for the level and time adjustments that maximise the
intermediate correlation coefficients d.
Will add location of source and interferer to this to reduce search space.</p>
<h2 id="args">Args</h2>
<dl>
<dt>scene</dt>
<dt>hrirs_input_path</dt>
<dt>xl_hat(ndarray): clean L short-time DFT coefficients (single-sided) per frequency bin and frame</dt>
<dt>xr_hat(ndarray): clean R short-time DFT coefficients (single-sided) per frequency bin and frame</dt>
<dt>yr_hat(ndarray): proc. R short-time DFT coefficients (single-sided) per frequency bin and frame</dt>
<dt><strong><code>J</code></strong> :&ensp;<code>int</code></dt>
<dd>number of one-third octave bands</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>number of frames for intermediate intelligibility measure</dd>
<dt><strong><code>fids</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>indices of frequency band edges</dd>
<dt><strong><code>cf</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>centre frequencies</dd>
<dt><strong><code>ntaus</code></strong> :&ensp;<code>int</code></dt>
<dd>number tau values to try out.</dd>
<dt><strong><code>ngammas</code></strong> :&ensp;<code>int</code></dt>
<dd>number gamma values to try out.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>d (ndarray): updated grid for intermediate intelligibility measure
p_ec_max (ndarray): grid containing maximum values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/ecplus.py#L15-L196" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ecplus(
    scene,
    hrirs_input_path,
    xl_hat,
    xr_hat,
    yl_hat,
    yr_hat,
    J,
    N,
    fids,
    cf,
    ntaus,
    ngammas,
):
    &#34;&#34;&#34;Run the equalisation-cancellation (EC) stage of the MBSTOI metric.
    The EC loop evaluates one huge equation in every iteration.
    See referenced notes for details.
    The left and right ear signals are level adjusted by gamma (in dB) and time
    shifted by tau relative to one-another and are thereafter subtracted.
    The processed signals are treated similarly.
    To obtain performance similar to that of humans,the EC stage adds jitter
    We are searching for the level and time adjustments that maximise the
    intermediate correlation coefficients d.
    Will add location of source and interferer to this to reduce search space.
    Args:
        scene
        hrirs_input_path
        xl_hat(ndarray): clean L short-time DFT coefficients (single-sided) per frequency bin and frame
        xr_hat(ndarray): clean R short-time DFT coefficients (single-sided) per frequency bin and frame
        yr_hat(ndarray): proc. R short-time DFT coefficients (single-sided) per frequency bin and frame
        J (int): number of one-third octave bands
        N (int): number of frames for intermediate intelligibility measure
        fids (ndarray): indices of frequency band edges
        cf (ndarray): centre frequencies
        ntaus (int): number tau values to try out.
        ngammas (int): number gamma values to try out.
    Returns:
        d (ndarray): updated grid for intermediate intelligibility measure
        p_ec_max (ndarray): grid containing maximum values
    &#34;&#34;&#34;

    # Get azimuth
    az = scene[&#34;azimuth_interferer_listener&#34;]  # azimuth interferer
    azimuth_degrees = np.zeros(48)
    azimuth_degrees[:24] = np.arange(0, 180, 7.5)
    azimuth_degrees[24:] = np.arange(-180, 0, 7.5)
    idx = np.where(np.abs(azimuth_degrees - az) == np.min(np.abs(azimuth_degrees - az)))
    azimuth = int(azimuth_degrees[idx])

    # Load ILD look up table where rows are azimuth, cols, frequency bands
    # ilds = loadmat(hrirs_input_path + &#34;ILDs_mparametric_v0.mat&#34;)[&#34;output&#34;]
    # ilds = ilds[int(idx[0]), :]

    [itds_iacc, ilds_timedomain] = MBSTOI.get_itds_ilds(
        azimuth, scene, hrirs_input_path
    )
    ilds = ilds_timedomain
    itds = itds_iacc

    # Values to define EC grid
    tau_min = -0.001  # Minumum interaural delay compensation in seconds. B: -0.01.
    tau_max = 0.001  # Maximum interaural delay compensation in seconds. B: 0.01.

    # Constants for jitter
    # ITD compensation standard deviation in seconds. Equation 6 Andersen et al. 2018 Refinement
    sigma_delta_0 = 65e-6
    # Constant for time shift deviation in seconds. Equation 6 Andersen et al. 2018
    tau_0 = 1.6e-3

    # Here intermediate correlation coefficients are evaluated for a discrete set of
    # gamma and tau values (a &#34;grid&#34;) and the highest value is chosen.
    d = np.zeros((J, np.shape(xl_hat)[1] - N + 1))
    p_ec_max = np.zeros((J, np.shape(xl_hat)[1] - N + 1))

    # Interaural compensation time values
    taus = np.linspace(np.min(itds), np.max(itds), ntaus)
    sigma_delta = np.sqrt(2) * sigma_delta_0 * (1 + (abs(taus) / tau_0))

    taus = np.expand_dims(taus, axis=0)
    # Equation 6 in Andersen et al. 2018
    sigma_delta = np.expand_dims(sigma_delta, axis=0)
    # ILD compensation standard deviation.  Equation 5 Andersen et al. 2018
    sigma_epsilon_0 = 1.5
    # Constant for level shift deviation in dB. Equation 5 Andersen et al. 2018
    alpha_0_db = 13
    # Constant for level shift deviation. Power for calculation of sigma delta gamma in equation 5 Andersen et al. 2018.
    p = 1.6
    # Defining gammas across frequency band so sigma epsilon doesn&#39;t need to be calculated inside every loop
    gammas = np.linspace(np.min(ilds), np.max(ilds), ngammas)
    # Jitter incorporated below - Equations 5 and 6 in Andersen et al. 2018
    sigma_epsilon = (
        np.sqrt(2) * sigma_epsilon_0 * (1 + (abs(gammas) / alpha_0_db) ** p) / 20
    )
    sigma_epsilon = np.expand_dims(sigma_epsilon, axis=0)
    epsexp = np.exp(2 * np.log(10) ** 2 * sigma_epsilon ** 2)
    gammas = gammas / 20
    ngammas = len(gammas)

    for i in range(J):  # per frequency band
        tauexp = np.exp(-1j * cf[i] * taus)
        tauexp2 = np.exp(-1j * 2 * cf[i] * taus)
        deltexp = np.exp(-2 * cf[i] ** 2 * sigma_delta ** 2)
        epsdelexp = np.exp(
            0.5
            * (
                np.ones((ntaus, 1))
                * (
                    np.log(10) ** 2 * sigma_epsilon ** 2
                    - cf[i] ** 2 * np.transpose(sigma_delta) ** 2
                )
                * np.ones((1, ngammas))
            )
        )

        for jj in range(np.shape(d)[1]):  # per frame
            seg_xl = xl_hat[int(fids[i, 0] - 1) : int(fids[i, 1]), jj : (jj + N)]
            seg_xr = xr_hat[int(fids[i, 0] - 1) : int(fids[i, 1]), jj : (jj + N)]
            seg_yl = yl_hat[int(fids[i, 0] - 1) : int(fids[i, 1]), jj : (jj + N)]
            seg_yr = yr_hat[int(fids[i, 0] - 1) : int(fids[i, 1]), jj : (jj + N)]

            # All normalised by subtracting mean
            Lx = np.sum(np.conj(seg_xl) * seg_xl, axis=0)
            Lx = np.expand_dims(Lx, axis=0)
            Lx = Lx - np.mean(Lx)
            Rx = np.sum(np.conj(seg_xr) * seg_xr, axis=0)
            Rx = np.expand_dims(Rx, axis=0)
            Rx = Rx - np.mean(Rx)
            rhox = np.sum(np.conj(seg_xr) * seg_xl, axis=0)
            rhox = np.expand_dims(rhox, axis=0)
            rhox = rhox - np.mean(rhox)
            Ly = np.sum(np.conj(seg_yl) * seg_yl, axis=0)
            Ly = np.expand_dims(Ly, axis=0)
            Ly = Ly - np.mean(Ly)
            Ry = np.sum(np.conj(seg_yr) * seg_yr, axis=0)
            Ry = np.expand_dims(Ry, axis=0)
            Ry = Ry - np.mean(Ry)
            rhoy = np.sum(np.conj(seg_yr) * seg_yl, axis=0)
            rhoy = np.expand_dims(rhoy, axis=0)
            rhoy = rhoy - np.mean(rhoy)

            # Evaluate parts of intermediate correlation - EC stage exhaustive search over ITD/ILD values
            # These correspond to equations 7 and 8 in Andersen et al. 2018
            # Calculate Exy
            firstpart = firstpartfunc(Lx, Ly, Rx, Ry, ntaus, gammas, epsexp)
            secondpart = secondpartfunc(Lx, Ly, rhoy, rhox, tauexp, epsdelexp, gammas)
            thirdpart = thirdpartfunc(Rx, Ry, rhoy, rhox, tauexp, epsdelexp, gammas)
            fourthpart = fourthpartfunc(rhox, rhoy, tauexp2, ngammas, deltexp)
            exy = firstpart - secondpart - thirdpart + fourthpart

            # Calculate Exx
            firstpart = firstpartfunc(Lx, Lx, Rx, Rx, ntaus, gammas, epsexp)
            secondpart = secondpartfunc(Lx, Lx, rhox, rhox, tauexp, epsdelexp, gammas)
            thirdpart = thirdpartfunc(Rx, Rx, rhox, rhox, tauexp, epsdelexp, gammas)
            fourthpart = fourthpartfunc(rhox, rhox, tauexp2, ngammas, deltexp)
            exx = firstpart - secondpart - thirdpart + fourthpart

            # Calculate Eyy
            firstpart = firstpartfunc(Ly, Ly, Ry, Ry, ntaus, gammas, epsexp)
            secondpart = secondpartfunc(Ly, Ly, rhoy, rhoy, tauexp, epsdelexp, gammas)
            thirdpart = thirdpartfunc(Ry, Ry, rhoy, rhoy, tauexp, epsdelexp, gammas)
            fourthpart = fourthpartfunc(rhoy, rhoy, tauexp2, ngammas, deltexp)
            eyy = firstpart - secondpart - thirdpart + fourthpart

            # Ensure that intermediate correlation will be sensible and compute it
            if np.min(abs(exx * eyy)) &lt; 1e-40:
                d[i, jj] = -1
                continue
            else:
                p = np.divide(exx, eyy)
                tmp = p.max(axis=0)
                idx1 = p.argmax(axis=0)

                # Return overall maximum and index
                p_ec_max[i, jj] = tmp.max(axis=0)
                idx2 = tmp.argmax(axis=0)

                d[i, jj] = np.divide(
                    exy[idx1[idx2], idx2],
                    np.sqrt(exx[idx1[idx2], idx2] * eyy[idx1[idx2], idx2]),
                )

    return d, p_ec_max</code></pre>
</details>
</dd>
<dt id="MBSTOI.get_itds_ilds"><code class="name flex">
<span>def <span class="ident">get_itds_ilds</span></span>(<span>azimuth, scene, hrir_input_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/ecplus.py#L259-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_itds_ilds(azimuth, scene, hrir_input_path):

    from MBSTOI import thirdoct

    tau_min = -0.001  # Minumum interaural delay compensation in seconds. B: -0.01.
    tau_max = 0.001  # Maximum interaural delay compensation in seconds. B: 0.01.
    gamma_min = -20  # Minumum interaural level compensation in dB
    gamma_max = 20  # Maximum interaural level compensation in dB

    # mparametricilds = loadmat(hrir_input_path + &#34;ILDs_mparametric_v0.mat&#34;)[&#34;output&#34;]

    # Import HRTFS for ITD calculations
    hrir_sr = 48000
    nyquist = hrir_sr / 2
    hrir = loadmat(f&#34;{hrir_input_path}{scene[&#39;hrirfilename&#39;][:-6]}&#34;)
    directions = hrir[&#34;M_directions&#34;]
    azimuth_degrees = np.zeros(48)
    azimuth_degrees[:24] = np.arange(0, 180, 7.5)
    azimuth_degrees[24:] = np.arange(-180, 0, 7.5)
    azidx = np.where(
        np.abs(azimuth_degrees - azimuth) == np.min(np.abs(azimuth_degrees - azimuth))
    )
    idx = (directions[1, :] == 0) &amp; (directions[0, :] == azimuth_degrees[azidx])
    hrir = np.squeeze(hrir[&#34;M_data&#34;][:, idx, :])
    # logging.info(
    #     f&#34;Interferer azimuth is {azimuth}, selecting {int(azimuth_degrees[azidx][0])}&#34;
    # )

    # Zero pad
    tmp = np.zeros((3000, 2))
    tmp[: len(hrir), :] = hrir  # zero pad hrir
    hrir = tmp

    # Filter into frequency bands
    fft_size = 512
    J = 15  # number frequency bands
    mn = 150  # Centre frequency of first 1/3 octave band in Hz

    # Get desired centre frequencies
    [H, cf, fids] = thirdoct(hrir_sr, fft_size, J, mn)
    cf = cf.flatten()

    # Apply 1/3 octave bands - calculate band edges using base 10 rules
    g = 10 ** (3 / 10)
    bandedge = g ** (1 / (2 * 3))
    flo = cf / bandedge
    fhi = cf * bandedge

    if nyquist &lt;= fhi[-1]:
        logging.error(&#34;Band edges exceed Nyquist frequency&#34;)

    # Create 6th order Butterworth Filter with SOS coefficients
    # Calculate downsampling factors per band
    factor = dsfactor(fhi, hrir_sr)
    # Get Butterworth SOS filter coefficients
    sos = sosfilter(cf, flo, fhi, hrir_sr, 6, factor)

    # Create array with SPL for each frequency band
    filtered_dict = []
    for ch in range(2):
        for idx in range(len(cf)):
            sd = signal.decimate(hrir[:, ch], factor[idx])
            y = signal.sosfilt(sos[idx], sd)
            spl = 20 * np.log10(np.std(y) / 2e-5)
            case = {
                &#34;cf&#34;: cf[idx],
                &#34;ch&#34;: ch,
                &#34;signal&#34;: y,
                &#34;newfs&#34;: int(hrir_sr / factor[idx]),
                &#34;siglength&#34;: len(y),
            }
            filtered_dict.append(case)

    # In each band, in time domain, find the delay corresponding to the maximum cross-correlation coefficient
    # Calculate ILDs on basis of rms ratio of filtered signals
    itds_iacc = np.zeros((len(cf)))
    # In each band, calculate ILDs
    ilds_timedomain = np.zeros((len(cf)))
    for f in range(len(cf)):
        xl = filtered_dict[f][&#34;signal&#34;]
        xr = filtered_dict[f + 15][&#34;signal&#34;]
        # ITD method via FFT
        # n = len(xl)
        fft_l = scipy.fft.fft(xl, axis=0)
        fft_r = np.conj(scipy.fft.fft(xr, axis=0))
        pwr_l = np.divide(np.sum(np.real(fft_l) ** 2 + np.imag(fft_l) ** 2), len(fft_l))
        pwr_r = np.divide(np.sum(np.real(fft_r) ** 2 + np.imag(fft_r) ** 2), len(fft_r))
        op = np.fft.ifft(fft_l * fft_r, axis=0)
        iacc = np.real(np.divide(op, np.sqrt(pwr_l * pwr_r)))
        delay_samp = np.where(iacc == np.max(iacc))
        delay_samp = int(delay_samp[0]) + 1
        if delay_samp &gt; len(iacc) / 2:
            delay_samp = delay_samp - len(iacc)
        time_delay = delay_samp / hrir_sr
        itds_iacc[f] = time_delay
        ilds_timedomain[f] = 20 * np.log10(
            np.sqrt(np.mean(xr ** 2)) / np.sqrt(np.mean(xl ** 2))
        )  # pos values for source on R

    tmp = (ilds_timedomain &lt; gamma_min) | (ilds_timedomain &gt; gamma_max)
    if tmp.any() == True:
        logging.error(&#34;ILDs outside of bounds.&#34;)

    tmp = (itds_iacc &lt; tau_min) | (itds_iacc &gt; tau_max)
    if tmp.any() == True:
        logging.error(&#34;ITDs outside of bounds.&#34;)

    return (
        itds_iacc,
        ilds_timedomain,
    )</code></pre>
</details>
</dd>
<dt id="MBSTOI.mbstoi"><code class="name flex">
<span>def <span class="ident">mbstoi</span></span>(<span>xl, xr, yl, yr, gridcoarseness=1)</span>
</code></dt>
<dd>
<div class="desc"><p>A Python implementation of the Modified Binaural Short-Time
Objective Intelligibility (MBSTOI) measure as described in:
A. H. Andersen, J. M. de Haan, Z.-H. Tan, and J. Jensen, “Refinement
and validation of the binaural short time objective intelligibility
measure for spatially diverse conditions,” Speech Communication,
vol. 102, pp. 1-13, Sep. 2018. A. H. Andersen, 10/12-2018</p>
<p>All title, copyrights and pending patents in and to the original MATLAB
Software are owned by Oticon A/S and/or Aalborg University. Please see
details at <a href="http://ah-andersen.net/code/">http://ah-andersen.net/code/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>clean speech signal from left ear</dd>
<dt><strong><code>xr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>clean speech signal from right ear.</dd>
<dt><strong><code>yl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>noisy/processed speech signal from left ear.</dd>
<dt><strong><code>yr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>noisy/processed speech signal from right ear.</dd>
<dt><strong><code>gridcoarseness</code></strong> :&ensp;<code>integer</code></dt>
<dd>grid coarseness as denominator of ntaus and ngammas (default: 1)</dd>
</dl>
<p>Returns
float: MBSTOI index d</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/mbstoi.py#L1-L210" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mbstoi(xl, xr, yl, yr, gridcoarseness=1):
    &#34;&#34;&#34;A Python implementation of the Modified Binaural Short-Time
    Objective Intelligibility (MBSTOI) measure as described in:
    A. H. Andersen, J. M. de Haan, Z.-H. Tan, and J. Jensen, “Refinement
    and validation of the binaural short time objective intelligibility
    measure for spatially diverse conditions,” Speech Communication,
    vol. 102, pp. 1-13, Sep. 2018. A. H. Andersen, 10/12-2018

    All title, copyrights and pending patents in and to the original MATLAB
    Software are owned by Oticon A/S and/or Aalborg University. Please see
    details at http://ah-andersen.net/code/

    Args:
        xl (ndarray): clean speech signal from left ear
        xr (ndarray): clean speech signal from right ear.
        yl (ndarray): noisy/processed speech signal from left ear.
        yr (ndarray): noisy/processed speech signal from right ear.
        gridcoarseness (integer): grid coarseness as denominator of ntaus and ngammas (default: 1)

    Returns
        float: MBSTOI index d

    &#34;&#34;&#34;

    import logging
    import numpy as np
    import math
    from scipy.signal import resample

    import MBSTOI

    # Basic STOI parameters
    fs_signal = MBSTOI.MASTER_FS
    fs = 10000  # Sample rate of proposed intelligibility measure in Hz
    N_frame = 256  # Window support in samples
    K = 512  # FFT size in samples
    J = 15  # Number of one-third octave bands
    mn = 150  # Centre frequency of first 1/3 octave band in Hz
    N = 30  # Number of frames for intermediate intelligibility measure (length analysis window)
    dyn_range = 40  # Speech dynamic range in dB

    # Values to define EC grid
    tau_min = -0.001  # Minumum interaural delay compensation in seconds. B: -0.01.
    tau_max = 0.001  # Maximum interaural delay compensation in seconds. B: 0.01.
    ntaus = math.ceil(100 / gridcoarseness)  # Number of tau values to try out
    gamma_min = -20  # Minumum interaural level compensation in dB
    gamma_max = 20  # Maximum interaural level compensation in dB
    ngammas = math.ceil(40 / gridcoarseness)  # Number of gamma values to try out

    # Constants for jitter
    # ITD compensation standard deviation in seconds. Equation 6 Andersen et al. 2018 Refinement
    sigma_delta_0 = 65e-6
    # ILD compensation standard deviation.  Equation 5 Andersen et al. 2018
    sigma_epsilon_0 = 1.5
    # Constant for level shift deviation in dB. Equation 5 Andersen et al. 2018
    alpha_0_db = 13
    # Constant for time shift deviation in seconds. Equation 6 Andersen et al. 2018
    tau_0 = 1.6e-3
    # Constant for level shift deviation. Power for calculation of sigma delta gamma in equation 5 Andersen et al. 2018.
    p = 1.6

    # Prepare signals, ensuring that inputs are column vectors
    xl = xl.flatten()
    xr = xr.flatten()
    yl = yl.flatten()
    yr = yr.flatten()

    # Resample signals to 10 kHz
    if fs_signal != fs:

        logging.debug(f&#34;Resampling signals with sr={fs} for MBSTOI calculation.&#34;)
        # Assumes fs_signal is 44.1 kHz
        l = len(xl)
        xl = resample(xl, int(l * (fs / fs_signal) + 1))
        xr = resample(xr, int(l * (fs / fs_signal) + 1))
        yl = resample(yl, int(l * (fs / fs_signal) + 1))
        yr = resample(yr, int(l * (fs / fs_signal) + 1))

    # Remove silent frames
    [xl, xr, yl, yr] = MBSTOI.remove_silent_frames(
        xl, xr, yl, yr, dyn_range, N_frame, N_frame / 2
    )

    # Handle case when signals are zeros
    if (
        abs(np.log10(np.linalg.norm(xl) / np.linalg.norm(yl))) &gt; 5.0
        or abs(np.log10(np.linalg.norm(xr) / np.linalg.norm(yr))) &gt; 5.0
    ):
        sii = 0

    # STDFT and filtering
    # Get 1/3 octave band matrix
    [H, cf, fids] = MBSTOI.thirdoct(fs, K, J, mn)  # (fs, nfft, num_bands, min_freq)
    cf = 2 * math.pi * cf  # This is now the angular frequency in radians per sec

    # Apply short time DFT to signals
    xl_hat = MBSTOI.stft(xl, N_frame, K)
    xr_hat = MBSTOI.stft(xr, N_frame, K)
    yl_hat = MBSTOI.stft(yl, N_frame, K)
    yr_hat = MBSTOI.stft(yr, N_frame, K)

    # Take single sided spectrum of signals and transpose
    idx = int(K / 2 + 1)
    xl_hat = np.real(np.transpose(xl_hat[:, 0:idx]))
    xr_hat = np.real(np.transpose(xr_hat[:, 0:idx]))
    yl_hat = np.real(np.transpose(yl_hat[:, 0:idx]))
    yr_hat = np.real(np.transpose(yr_hat[:, 0:idx]))

    # Compute intermediate correlation via EC search
    logging.info(f&#34;Starting EC evaluation&#34;)
    # Here intermeduiate correlation coefficients are evaluated for a discrete set of
    # gamma and tau values (a &#34;grid&#34;) and the highest value is chosen.
    d = np.zeros((J, np.shape(xl_hat)[1] - N + 1))
    p_ec_max = np.zeros((J, np.shape(xl_hat)[1] - N + 1))

    # Interaural compensation time and level values
    taus = np.linspace(tau_min, tau_max, ntaus)
    gammas = np.linspace(gamma_min, gamma_max, ngammas)

    # Jitter incorporated below - Equations 5 and 6 in Andersen et al. 2018
    sigma_epsilon = (
        np.sqrt(2) * sigma_epsilon_0 * (1 + (abs(gammas) / alpha_0_db) ** p) / 20
    )
    gammas = gammas / 20
    sigma_delta = np.sqrt(2) * sigma_delta_0 * (1 + (abs(taus) / tau_0))

    logging.info(f&#34;Processing EC stage&#34;)
    d, p_ec_max = MBSTOI.ec(
        xl_hat,
        xr_hat,
        yl_hat,
        yr_hat,
        J,
        N,
        fids,
        cf.flatten(),
        taus,
        ntaus,
        gammas,
        ngammas,
        d,
        p_ec_max,
        sigma_epsilon,
        sigma_delta,
    )

    # Compute the better ear STOI
    logging.info(f&#34;Computing better ear intermediate correlation coefficients&#34;)
    # Arrays for the 1/3 octave envelope
    Xl = np.zeros((J, np.shape(xl_hat)[1]))
    Xr = np.zeros((J, np.shape(xl_hat)[1]))
    Yl = np.zeros((J, np.shape(xl_hat)[1]))
    Yr = np.zeros((J, np.shape(xl_hat)[1]))

    # Apply 1/3 octave bands as described in Eq.(1) of the STOI article
    for k in range(np.shape(xl_hat)[1]):
        Xl[:, k] = np.dot(H, abs(xl_hat[:, k]) ** 2)
        Xr[:, k] = np.dot(H, abs(xr_hat[:, k]) ** 2)
        Yl[:, k] = np.dot(H, abs(yl_hat[:, k]) ** 2)
        Yr[:, k] = np.dot(H, abs(yr_hat[:, k]) ** 2)

    # Arrays for better-ear correlations
    dl_interm = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    dr_interm = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    pl = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    pr = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))

    # Compute temporary better-ear correlations
    for m in range(N, np.shape(xl_hat)[1]):
        Xl_seg = Xl[:, (m - N) : m]
        Xr_seg = Xr[:, (m - N) : m]
        Yl_seg = Yl[:, (m - N) : m]
        Yr_seg = Yr[:, (m - N) : m]

        for n in range(J):
            xln = Xl_seg[n, :] - np.sum(Xl_seg[n, :]) / N
            xrn = Xr_seg[n, :] - np.sum(Xr_seg[n, :]) / N
            yln = Yl_seg[n, :] - np.sum(Yl_seg[n, :]) / N
            yrn = Yr_seg[n, :] - np.sum(Yr_seg[n, :]) / N
            pl[n, m - N] = np.sum(xln * xln) / np.sum(yln * yln)
            pr[n, m - N] = np.sum(xrn * xrn) / np.sum(yrn * yrn)
            dl_interm[n, m - N] = np.sum(xln * yln) / (
                np.linalg.norm(xln) * np.linalg.norm(yln)
            )
            dr_interm[n, m - N] = np.sum(xrn * yrn) / (
                np.linalg.norm(xrn) * np.linalg.norm(yrn)
            )

    # Get the better ear intermediate coefficients
    idx = np.isfinite(dl_interm)
    dl_interm[~idx] = 0
    idx = np.isfinite(dr_interm)
    dr_interm[~idx] = 0
    p_be_max = np.maximum(pl, pr)
    dbe_interm = np.zeros((np.shape(dl_interm)))

    idx = pl &gt; pr
    dbe_interm[idx] = dl_interm[idx]
    dbe_interm[~idx] = dr_interm[~idx]

    # Compute STOI measure
    # Whenever a single ear provides a higher correlation than the corresponding EC
    # processed alternative,the better-ear correlation is used.
    idx = p_be_max &gt; p_ec_max
    d[idx] = dbe_interm[idx]
    sii = np.mean(d)

    logging.info(&#34;MBSTOI processing complete&#34;)

    return sii</code></pre>
</details>
</dd>
<dt id="MBSTOI.mbstoi_noEC"><code class="name flex">
<span>def <span class="ident">mbstoi_noEC</span></span>(<span>xl, xr, yl, yr)</span>
</code></dt>
<dd>
<div class="desc"><p>A Python implementation of the Modified Binaural Short-Time
Objective Intelligibility (MBSTOI) measure as described in:
A. H. Andersen, J. M. de Haan, Z.-H. Tan, and J. Jensen, “Refinement
and validation of the binaural short time objective intelligibility
measure for spatially diverse conditions,” Speech Communication,
vol. 102, pp. 1-13, Sep. 2018. A. H. Andersen, 10/12-2018</p>
<p>Note that this approximation replaces the EC-stage with a simple
summing of signals on the assumption that the target speech is in
front of the listener.</p>
<p>All title, copyrights and pending patents in and to the original MATLAB
MBSTOI Software are owned by Oticon A/S and/or Aalborg University. Please see
details at <a href="http://ah-andersen.net/code/">http://ah-andersen.net/code/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>clean speech signal from left ear</dd>
<dt><strong><code>xr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>clean speech signal from right ear.</dd>
<dt><strong><code>yl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>noisy/processed speech signal from left ear.</dd>
<dt><strong><code>yr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>noisy/processed speech signal from right ear.</dd>
</dl>
<p>Returns
float: MBSTOI index d</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/mbstoi_noEC.py#L1-L175" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mbstoi_noEC(xl, xr, yl, yr):
    &#34;&#34;&#34;A Python implementation of the Modified Binaural Short-Time
    Objective Intelligibility (MBSTOI) measure as described in:
    A. H. Andersen, J. M. de Haan, Z.-H. Tan, and J. Jensen, “Refinement
    and validation of the binaural short time objective intelligibility
    measure for spatially diverse conditions,” Speech Communication,
    vol. 102, pp. 1-13, Sep. 2018. A. H. Andersen, 10/12-2018

    Note that this approximation replaces the EC-stage with a simple
    summing of signals on the assumption that the target speech is in
    front of the listener.

    All title, copyrights and pending patents in and to the original MATLAB
    MBSTOI Software are owned by Oticon A/S and/or Aalborg University. Please see
    details at http://ah-andersen.net/code/

    Args:
        xl (ndarray): clean speech signal from left ear
        xr (ndarray): clean speech signal from right ear.
        yl (ndarray): noisy/processed speech signal from left ear.
        yr (ndarray): noisy/processed speech signal from right ear.

    Returns
        float: MBSTOI index d

    &#34;&#34;&#34;

    import logging
    import numpy as np
    import math
    from scipy.signal import resample

    import MBSTOI

    # Basic STOI parameters
    fs_signal = MBSTOI.MASTER_FS
    fs = 10000  # Sample rate of proposed intelligibility measure in Hz
    N_frame = 256  # Window support in samples
    K = 512  # FFT size in samples
    J = 15  # Number of one-third octave bands
    mn = 150  # Centre frequency of first 1/3 octave band in Hz
    N = 30  # Number of frames for intermediate intelligibility measure (length analysis window)
    dyn_range = 40  # Speech dynamic range in dB

    # Prepare signals, ensuring that inputs are column vectors
    xl = xl.flatten()
    xr = xr.flatten()
    yl = yl.flatten()
    yr = yr.flatten()

    # Resample signals to 10 kHz
    if fs_signal != fs:

        logging.debug(f&#34;Resampling signals with sr={fs} for MBSTOI calculation.&#34;)
        # Assumes fs_signal is 44.1 kHz
        l = len(xl)
        xl = resample(xl, int(l * (fs / fs_signal) + 1))
        xr = resample(xr, int(l * (fs / fs_signal) + 1))
        yl = resample(yl, int(l * (fs / fs_signal) + 1))
        yr = resample(yr, int(l * (fs / fs_signal) + 1))

    # Remove silent frames
    [xl, xr, yl, yr] = MBSTOI.remove_silent_frames(
        xl, xr, yl, yr, dyn_range, N_frame, N_frame / 2
    )

    # Handle case when signals are zeros
    if (
        abs(np.log10(np.linalg.norm(xl) / np.linalg.norm(xl))) &gt; 5.0
        or abs(np.log10(np.linalg.norm(xr) / np.linalg.norm(yr))) &gt; 5.0
    ):
        sii = 0

    # STDFT and filtering
    # Get 1/3 octave band matrix
    [H, cf, fids] = MBSTOI.thirdoct(fs, K, J, mn)  # (fs, nfft, num_bands, min_freq)
    cf = 2 * math.pi * cf  # This is now the angular frequency in radians per sec

    # Apply short time DFT to signals
    xl_hat = MBSTOI.stft(xl, N_frame, K)
    xr_hat = MBSTOI.stft(xr, N_frame, K)
    yl_hat = MBSTOI.stft(yl, N_frame, K)
    yr_hat = MBSTOI.stft(yr, N_frame, K)

    # Take single sided spectrum of signals and transpose
    idx = int(K / 2 + 1)
    xl_hat = np.real(np.transpose(xl_hat[:, 0:idx]))
    xr_hat = np.real(np.transpose(xr_hat[:, 0:idx]))
    yl_hat = np.real(np.transpose(yl_hat[:, 0:idx]))
    yr_hat = np.real(np.transpose(yr_hat[:, 0:idx]))

    # Compute intermediate correlation via simple summing of signals
    d = np.zeros((J, np.shape(xl_hat)[1] - N + 1))
    p = np.zeros((J, np.shape(xl_hat)[1] - N + 1))

    Xl = np.zeros((J, np.shape(xl_hat)[1]))
    Xr = np.zeros((J, np.shape(xl_hat)[1]))
    Yl = np.zeros((J, np.shape(xl_hat)[1]))
    Yr = np.zeros((J, np.shape(xl_hat)[1]))

    # Apply 1/3 octave bands as described in Eq.(1) of the STOI article
    for k in range(np.shape(xl_hat)[1]):
        Xl[:, k] = np.dot(H, abs(xl_hat[:, k]) ** 2)
        Xr[:, k] = np.dot(H, abs(xr_hat[:, k]) ** 2)
        Yl[:, k] = np.dot(H, abs(yl_hat[:, k]) ** 2)
        Yr[:, k] = np.dot(H, abs(yr_hat[:, k]) ** 2)

    # Compute intermediate correlations
    for m in range(N, np.shape(xl_hat)[1]):
        X_seg = Xl[:, (m - N) : m] + Xr[:, (m - N) : m]
        Y_seg = Yl[:, (m - N) : m] + Yr[:, (m - N) : m]

        for n in range(J):
            xn = X_seg[n, :] - np.sum(X_seg[n, :]) / N
            yn = Y_seg[n, :] - np.sum(Y_seg[n, :]) / N
            p[n, m - N] = np.sum(xn * xn) / np.sum(yn * yn)
            d[n, m - N] = np.sum(xn * yn) / (np.linalg.norm(xn) * np.linalg.norm(yn))

    # Replace non-finite values with 0
    idx = np.isfinite(d)
    d[~idx] = 0
    idx = np.isfinite(d)
    d[~idx] = 0

    # Compute the better ear STOI
    logging.info(f&#34;Computing better ear intermediate correlation coefficients&#34;)
    # Arrays for better-ear correlations
    dl_interm = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    dr_interm = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    pl = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    pr = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))

    # Compute temporary better-ear correlations
    for m in range(N, np.shape(xl_hat)[1]):
        Xl_seg = Xl[:, (m - N) : m]
        Xr_seg = Xr[:, (m - N) : m]
        Yl_seg = Yl[:, (m - N) : m]
        Yr_seg = Yr[:, (m - N) : m]

        for n in range(J):
            xln = Xl_seg[n, :] - np.sum(Xl_seg[n, :]) / N
            xrn = Xr_seg[n, :] - np.sum(Xr_seg[n, :]) / N
            yln = Yl_seg[n, :] - np.sum(Yl_seg[n, :]) / N
            yrn = Yr_seg[n, :] - np.sum(Yr_seg[n, :]) / N
            pl[n, m - N] = np.sum(xln * xln) / np.sum(yln * yln)
            pr[n, m - N] = np.sum(xrn * xrn) / np.sum(yrn * yrn)
            dl_interm[n, m - N] = np.sum(xln * yln) / (
                np.linalg.norm(xln) * np.linalg.norm(yln)
            )
            dr_interm[n, m - N] = np.sum(xrn * yrn) / (
                np.linalg.norm(xrn) * np.linalg.norm(yrn)
            )

    # Get the better ear intermediate coefficients
    idx = np.isfinite(dl_interm)
    dl_interm[~idx] = 0
    idx = np.isfinite(dr_interm)
    dr_interm[~idx] = 0
    p_be_max = np.maximum(pl, pr)
    dbe_interm = np.zeros((np.shape(dl_interm)))

    idx = pl &gt; pr
    dbe_interm[idx] = dl_interm[idx]
    dbe_interm[~idx] = dr_interm[~idx]

    # Compute STOI measure
    # Whenever a single ear provides a higher correlation than the corresponding EC
    # processed alternative,the better-ear correlation is used.
    idx = p_be_max &gt; p
    d[idx] = dbe_interm[idx]
    sii = np.mean(d)

    logging.info(&#34;MBSTOI no-EC processing complete&#34;)

    return sii</code></pre>
</details>
</dd>
<dt id="MBSTOI.mbstoiplus"><code class="name flex">
<span>def <span class="ident">mbstoiplus</span></span>(<span>xl, xr, yl, yr, scene, hrirs_input_path, ntaus, ngammas)</span>
</code></dt>
<dd>
<div class="desc"><p>A Python implementation of the Modified Binaural Short-Time
Objective Intelligibility (MBSTOI) measure as described in:
A. H. Andersen, J. M. de Haan, Z.-H. Tan, and J. Jensen, “Refinement
and validation of the binaural short time objective intelligibility
measure for spatially diverse conditions,” Speech Communication,
vol. 102, pp. 1-13, Sep. 2018. A. H. Andersen, 10/12-2018</p>
<p>All title, copyrights and pending patents in and to the original MATLAB
Software are owned by Oticon A/S and/or Aalborg University. Please see
details at <a href="http://ah-andersen.net/code/">http://ah-andersen.net/code/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>clean speech signal from left ear</dd>
<dt><strong><code>xr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>clean speech signal from right ear.</dd>
<dt><strong><code>yl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>noisy/processed speech signal from left ear.</dd>
<dt><strong><code>yr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>noisy/processed speech signal from right ear.</dd>
<dt><strong><code>scene</code></strong> :&ensp;<code>dict</code></dt>
<dd>scene specification - replace with just azimuth?</dd>
<dt><strong><code>hrirs_input_path</code></strong> :&ensp;<code>str</code></dt>
<dd>input path for HRIRs</dd>
<dt><strong><code>ntaus</code></strong> :&ensp;<code>int</code></dt>
<dd>number tau values to try out.</dd>
<dt><strong><code>ngammas</code></strong> :&ensp;<code>int</code></dt>
<dd>number gamma values to try out.</dd>
</dl>
<p>Returns
float: MBSTOI index d</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/mbstoiplus.py#L10-L174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mbstoiplus(xl, xr, yl, yr, scene, hrirs_input_path, ntaus, ngammas):
    &#34;&#34;&#34;A Python implementation of the Modified Binaural Short-Time
    Objective Intelligibility (MBSTOI) measure as described in:
    A. H. Andersen, J. M. de Haan, Z.-H. Tan, and J. Jensen, “Refinement
    and validation of the binaural short time objective intelligibility
    measure for spatially diverse conditions,” Speech Communication,
    vol. 102, pp. 1-13, Sep. 2018. A. H. Andersen, 10/12-2018

    All title, copyrights and pending patents in and to the original MATLAB
    Software are owned by Oticon A/S and/or Aalborg University. Please see
    details at http://ah-andersen.net/code/

    Args:
        xl (ndarray): clean speech signal from left ear
        xr (ndarray): clean speech signal from right ear.
        yl (ndarray): noisy/processed speech signal from left ear.
        yr (ndarray): noisy/processed speech signal from right ear.
        scene (dict): scene specification - replace with just azimuth?
        hrirs_input_path (str): input path for HRIRs
        ntaus (int): number tau values to try out.
        ngammas (int): number gamma values to try out.

    Returns
        float: MBSTOI index d

    &#34;&#34;&#34;

    # Basic STOI parameters
    fs_signal = MBSTOI.MASTER_FS
    fs = 10000  # Sample rate of proposed intelligibility measure in Hz
    N_frame = 256  # Window support in samples
    K = 512  # FFT size in samples
    J = 15  # Number of one-third octave bands
    mn = 150  # Centre frequency of first 1/3 octave band in Hz
    N = 30  # Number of frames for intermediate intelligibility measure (length analysis window)
    dyn_range = 40  # Speech dynamic range in dB

    # Prepare signals, ensuring that inputs are column vectors
    xl = xl.flatten()
    xr = xr.flatten()
    yl = yl.flatten()
    yr = yr.flatten()

    # Resample signals to 10 kHz
    if fs_signal != fs:

        logging.debug(f&#34;Resampling signals with sr={fs} for MBSTOI calculation.&#34;)
        # Assumes fs_signal is 44.1 kHz
        l = len(xl)
        xl = resample(xl, int(l * (fs / fs_signal) + 1))
        xr = resample(xr, int(l * (fs / fs_signal) + 1))
        yl = resample(yl, int(l * (fs / fs_signal) + 1))
        yr = resample(yr, int(l * (fs / fs_signal) + 1))

    # Remove silent frames
    [xl, xr, yl, yr] = MBSTOI.remove_silent_frames(
        xl, xr, yl, yr, dyn_range, N_frame, N_frame / 2
    )

    # Handle case when signals are zeros
    if (
        abs(np.log10(np.linalg.norm(xl) / np.linalg.norm(xl))) &gt; 5.0
        or abs(np.log10(np.linalg.norm(xr) / np.linalg.norm(yr))) &gt; 5.0
    ):
        sii = 0

    # STDFT and filtering
    # Get 1/3 octave band matrix
    [H, cf, fids] = MBSTOI.thirdoct(fs, K, J, mn)  # (fs, nfft, num_bands, min_freq)
    cf = 2 * math.pi * cf  # This is now the angular frequency in radians per sec

    # Apply short time DFT to signals
    xl_hat = MBSTOI.stft(xl, N_frame, K)
    xr_hat = MBSTOI.stft(xr, N_frame, K)
    yl_hat = MBSTOI.stft(yl, N_frame, K)
    yr_hat = MBSTOI.stft(yr, N_frame, K)

    # Take single sided spectrum of signals and transpose
    idx = int(K / 2 + 1)
    xl_hat = np.real(np.transpose(xl_hat[:, 0:idx]))
    xr_hat = np.real(np.transpose(xr_hat[:, 0:idx]))
    yl_hat = np.real(np.transpose(yl_hat[:, 0:idx]))
    yr_hat = np.real(np.transpose(yr_hat[:, 0:idx]))

    # Compute intermediate correlation via EC search
    logging.info(f&#34;Starting EC evaluation&#34;)
    d, p_ec_max = MBSTOI.ecplus(
        scene,
        hrirs_input_path,
        xl_hat,
        xr_hat,
        yl_hat,
        yr_hat,
        J,
        N,
        fids,
        cf.flatten(),
        ntaus,
        ngammas,
    )

    # Compute the better ear STOI
    logging.info(f&#34;Computing better ear intermediate correlation coefficients&#34;)
    # Arrays for the 1/3 octave envelope
    Xl = np.zeros((J, np.shape(xl_hat)[1]))
    Xr = np.zeros((J, np.shape(xl_hat)[1]))
    Yl = np.zeros((J, np.shape(xl_hat)[1]))
    Yr = np.zeros((J, np.shape(xl_hat)[1]))

    # Apply 1/3 octave bands as described in Eq.(1) of the STOI article
    for k in range(np.shape(xl_hat)[1]):
        Xl[:, k] = np.dot(H, abs(xl_hat[:, k]) ** 2)
        Xr[:, k] = np.dot(H, abs(xr_hat[:, k]) ** 2)
        Yl[:, k] = np.dot(H, abs(yl_hat[:, k]) ** 2)
        Yr[:, k] = np.dot(H, abs(yr_hat[:, k]) ** 2)

    # Arrays for better-ear correlations
    dl_interm = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    dr_interm = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    pl = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))
    pr = np.zeros((J, len(range(N, len(xl_hat[1]) + 1))))

    # Compute temporary better-ear correlations
    for m in range(N, np.shape(xl_hat)[1]):
        Xl_seg = Xl[:, (m - N) : m]
        Xr_seg = Xr[:, (m - N) : m]
        Yl_seg = Yl[:, (m - N) : m]
        Yr_seg = Yr[:, (m - N) : m]

        for n in range(J):
            xln = Xl_seg[n, :] - np.sum(Xl_seg[n, :]) / N
            xrn = Xr_seg[n, :] - np.sum(Xr_seg[n, :]) / N
            yln = Yl_seg[n, :] - np.sum(Yl_seg[n, :]) / N
            yrn = Yr_seg[n, :] - np.sum(Yr_seg[n, :]) / N
            pl[n, m - N] = np.sum(xln * xln) / np.sum(yln * yln)
            pr[n, m - N] = np.sum(xrn * xrn) / np.sum(yrn * yrn)
            dl_interm[n, m - N] = np.sum(xln * yln) / (
                np.linalg.norm(xln) * np.linalg.norm(yln)
            )
            dr_interm[n, m - N] = np.sum(xrn * yrn) / (
                np.linalg.norm(xrn) * np.linalg.norm(yrn)
            )

    # Get the better ear intermediate coefficients
    idx = np.isfinite(dl_interm)
    dl_interm[~idx] = 0
    idx = np.isfinite(dr_interm)
    dr_interm[~idx] = 0
    p_be_max = np.maximum(pl, pr)
    dbe_interm = np.zeros((np.shape(dl_interm)))

    idx = pl &gt; pr
    dbe_interm[idx] = dl_interm[idx]
    dbe_interm[~idx] = dr_interm[~idx]

    # Compute STOI measure
    # Whenever a single ear provides a higher correlation than the corresponding EC
    # processed alternative,the better-ear correlation is used.
    idx = p_be_max &gt; p_ec_max
    d[idx] = dbe_interm[idx]
    sii = np.mean(d)

    logging.info(&#34;MBSTOI processing complete&#34;)

    return sii</code></pre>
</details>
</dd>
<dt id="MBSTOI.mparametricild"><code class="name flex">
<span>def <span class="ident">mparametricild</span></span>(<span>freq_hz, azimuth_degs)</span>
</code></dt>
<dd>
<div class="desc"><p>Translation of Michael Akeroyd (MAA) and colleagues' MATLAB code for computing
interaural level differences based on frequency and azimuth in degrees.
MATLAB copyright MAA Feb 2020</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>freq_hz</code></strong> :&ensp;<code>float</code></dt>
<dd>frequency in Hz</dd>
<dt><strong><code>azimuth_degs</code></strong> :&ensp;<code>int</code></dt>
<dd>azimuth in degrees</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>ILD (float): interaural level difference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/mparametricild.py#L10-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mparametricild(freq_hz, azimuth_degs):
    &#34;&#34;&#34;
    Translation of Michael Akeroyd (MAA) and colleagues&#39; MATLAB code for computing
    interaural level differences based on frequency and azimuth in degrees.
    MATLAB copyright MAA Feb 2020

    Args:
        freq_hz (float): frequency in Hz
        azimuth_degs (int): azimuth in degrees

    Returns:
        ILD (float): interaural level difference

    &#34;&#34;&#34;
    f_logkhz = np.log10(freq_hz / 1000)
    a_rads = azimuth_degs / 360 * 2 * math.pi

    # parameters pasted from excel 20200402a
    mainparameters = np.zeros((5, 14))
    mainparameters[0, :] = [
        13.0621,
        11.6956,
        -4.0224,
        0.6882,
        0.2223,
        2.8651,
        0.2034,
        0.3508,
        -1.7716,
        0.3034,
        0.1137,
        0.6188,
        0.7882,
        0.0489,
    ]
    mainparameters[1, :] = [
        -0.5782,
        0.5041,
        -0.9590,
        -0.6493,
        0.3741,
        -0.1439,
        0.0345,
        0.1678,
        -0.0443,
        0.2955,
        0.0678,
        0.0389,
        0.6539,
        0.0640,
    ]
    mainparameters[2, :] = [
        0.6466,
        1.1185,
        -9.0378,
        1.3305,
        0.2196,
        -7.5159,
        0.0522,
        0.3522,
        1.2418,
        0.2660,
        0.1070,
        -0.1280,
        0.5030,
        0.0300,
    ]
    mainparameters[3, :] = [
        -0.2238,
        1.6047,
        -6.0000,
        1.3402,
        0.0300,
        2.8675,
        -1.0099,
        0.1350,
        -0.0405,
        0.8272,
        0.0300,
        -0.0282,
        0.4746,
        0.0539,
    ]
    mainparameters[4, :] = [
        -0.0629,
        0.3258,
        -0.1153,
        0.7487,
        0.1261,
        -0.0551,
        0.2448,
        0.0919,
        0.0398,
        -0.3022,
        0.1494,
        0.1600,
        0.6487,
        0.5839,
    ]

    fivekhzpertubationparameters = np.array([-0.2664, 0.7067, 0.0763, 2.7500, 0.2000])

    # extract
    row = 0
    primarymagnitude_line_slope = mainparameters[row, 0]
    primarymagnitude_line_constant = mainparameters[row, 1]
    primarymagnitude_normal = np.zeros((4, 3))
    for n in range(4):
        primarymagnitude_normal[n, 0] = mainparameters[row, (n + 1) * 3 - 1]  # mag
        primarymagnitude_normal[n, 1] = mainparameters[row, (n + 1) * 3 + 0]  # mu
        primarymagnitude_normal[n, 2] = mainparameters[row, (n + 1) * 3 + 1]  # std

    row = 1
    asymmetry_line_slope = mainparameters[row, 0]
    asymmetry_line_constant = mainparameters[row, 1]
    asymmetry_normal = np.zeros((4, 3))
    for n in range(4):
        asymmetry_normal[n, 0] = mainparameters[row, (n + 1) * 3 - 1]  # mag
        asymmetry_normal[n, 1] = mainparameters[row, (n + 1) * 3 + 0]  # mu
        asymmetry_normal[n, 2] = mainparameters[row, (n + 1) * 3 + 1]  # std

    row = 2
    dipmagnitude_line_slope = mainparameters[row, 0]
    dipmagnitude_line_constant = mainparameters[row, 1]
    dipmagnitude_normal = np.zeros((4, 3))
    for n in range(4):
        dipmagnitude_normal[n, 0] = mainparameters[row, (n + 1) * 3 - 1]  # mag
        dipmagnitude_normal[n, 1] = mainparameters[row, (n + 1) * 3 + 0]  # mu
        dipmagnitude_normal[n, 2] = mainparameters[row, (n + 1) * 3 + 1]  # std

    row = 3
    dipmu_line_slope = mainparameters[row, 0]
    dipmu_line_constant = mainparameters[row, 1]
    dipmu_normal = np.zeros((4, 3))
    for n in range(4):
        dipmu_normal[n, 0] = mainparameters[row, (n + 1) * 3 - 1]  # mag
        dipmu_normal[n, 1] = mainparameters[row, (n + 1) * 3 + 0]  # mu
        dipmu_normal[n, 2] = mainparameters[row, (n + 1) * 3 + 1]  # std

    row = 4
    dipstd_line_slope = mainparameters[row, 0]
    dipstd_line_constant = mainparameters[row, 1]
    dipstd_normal = np.zeros((4, 3))
    for n in range(4):
        dipstd_normal[n, 0] = mainparameters[row, (n + 1) * 3 - 1]  # mag
        dipstd_normal[n, 1] = mainparameters[row, (n + 1) * 3 + 0]  # mu
        dipstd_normal[n, 2] = mainparameters[row, (n + 1) * 3 + 1]  # std

    fivekhzperturb_magnitude = np.zeros((4, 1))
    fivekhzperturb_magnitude[0] = fivekhzpertubationparameters[0]  # mag
    fivekhzperturb_magnitude[1] = fivekhzpertubationparameters[1]  # mu
    fivekhzperturb_magnitude[2] = fivekhzpertubationparameters[2]  # std
    fivekhzperturb_mu = fivekhzpertubationparameters[3]
    fivekhzperturb_std = fivekhzpertubationparameters[4]

    # Get the parameters for this frequency

    linearcontribution = (
        primarymagnitude_line_slope * f_logkhz + primarymagnitude_line_constant
    )
    normalcontribution = np.zeros((4, 1))
    for n in range(4):
        normalcontribution[n] = primarymagnitude_normal[n, 0] * norm.pdf(
            f_logkhz, primarymagnitude_normal[n, 1], primarymagnitude_normal[n, 2]
        )

    primarymagnitude = linearcontribution + np.sum(normalcontribution)

    linearcontribution = asymmetry_line_slope * f_logkhz + asymmetry_line_constant
    for n in range(4):
        normalcontribution[n] = asymmetry_normal[n, 0] * norm.pdf(
            f_logkhz, asymmetry_normal[n, 1], asymmetry_normal[n, 2]
        )

    asymmetryparameter = linearcontribution + np.sum(normalcontribution)

    linearcontribution = dipmagnitude_line_slope * f_logkhz + dipmagnitude_line_constant
    for n in range(4):
        normalcontribution[n] = dipmagnitude_normal[n, 0] * norm.pdf(
            f_logkhz, dipmagnitude_normal[n, 1], dipmagnitude_normal[n, 2]
        )

    dipmagnitude = linearcontribution + np.sum(normalcontribution)

    linearcontribution = dipmu_line_slope * f_logkhz + dipmu_line_constant
    for n in range(4):
        normalcontribution[n] = dipmu_normal[n, 0] * norm.pdf(
            f_logkhz, dipmu_normal[n, 1], dipmu_normal[n, 2]
        )

    dipmu = linearcontribution + np.sum(normalcontribution)

    linearcontribution = dipstd_line_slope * f_logkhz + dipstd_line_constant
    for n in range(4):
        normalcontribution[n] = dipstd_normal[n, 0] * norm.pdf(
            f_logkhz, dipstd_normal[n, 1], dipstd_normal[n, 2]
        )
    dipstd = linearcontribution + np.sum(normalcontribution)

    linearcontribution = 0
    normalcontribution = fivekhzperturb_magnitude[0] * norm.pdf(
        f_logkhz, fivekhzperturb_magnitude[1], fivekhzperturb_magnitude[2]
    )
    fivekhzmagnitude = linearcontribution + normalcontribution

    # Store for output
    parameters_primarymagnitude = primarymagnitude
    parameters_asymmetry = asymmetryparameter
    parameters_dipmagnitude = dipmagnitude
    parameters_dipmu = dipmu
    parameters_dipstd = dipstd
    parameters_fivekhzmagnitude = fivekhzmagnitude

    # .. and then use them to get the ILD ...
    primarysinusoid = primarymagnitude * np.sin(a_rads)
    asymmetry = asymmetryparameter * np.sin(2 * a_rads) + 1
    dip = dipmagnitude * norm.pdf(a_rads, dipmu, dipstd)
    fivekhz = fivekhzmagnitude * norm.pdf(a_rads, fivekhzperturb_mu, fivekhzperturb_std)

    ild_db = float(primarysinusoid * asymmetry + dip + fivekhz)
    logging.info(f&#34;ILD = {ild_db}&#34;)

    return ild_db</code></pre>
</details>
</dd>
<dt id="MBSTOI.remove_silent_frames"><code class="name flex">
<span>def <span class="ident">remove_silent_frames</span></span>(<span>xl, xr, yl, yr, dyn_range, framelen, hop)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove silent frames of x and y based on x
A frame is excluded if its energy is lower than max(energy) - dyn_range
The frame exclusion is based solely on x, the clean speech signal
Based on mpariente/pystoi/utils.py</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>clean input signal left channel</dd>
<dt><strong><code>xr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>clean input signal right channel</dd>
<dt><strong><code>yl</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>degraded/processed signal left channel</dd>
<dt><strong><code>yr</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>degraded/processed signal right channel</dd>
<dt><strong><code>dyn_range</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>range, energy range to determine which frame is silent, 40</dd>
<dt><strong><code>framelen</code></strong> :&ensp;<code>int</code></dt>
<dd>N, window size for energy evaluation, 256</dd>
<dt><strong><code>hop</code></strong> :&ensp;<code>int</code></dt>
<dd>K, hop size for energy evaluation, 128</dd>
</dl>
<p>Returns :
xl (ndarray): xl without the silent frames
xr (ndarray): xr without the silent frames
yl (ndarray): yl without the silent frames in x
yl (ndarray): yl without the silent frames in x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/remove_silent_frames.py#L1-L75" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remove_silent_frames(xl, xr, yl, yr, dyn_range, framelen, hop):
    &#34;&#34;&#34; 
    Remove silent frames of x and y based on x
    A frame is excluded if its energy is lower than max(energy) - dyn_range
    The frame exclusion is based solely on x, the clean speech signal
    Based on mpariente/pystoi/utils.py

    Args:
        xl (ndarray): clean input signal left channel
        xr (ndarray): clean input signal right channel
        yl (ndarray): degraded/processed signal left channel
        yr (ndarray): degraded/processed signal right channel
        dyn_range (ndarray): range, energy range to determine which frame is silent, 40
        framelen (int): N, window size for energy evaluation, 256
        hop (int): K, hop size for energy evaluation, 128

    Returns :
        xl (ndarray): xl without the silent frames
        xr (ndarray): xr without the silent frames
        yl (ndarray): yl without the silent frames in x
        yl (ndarray): yl without the silent frames in x
    &#34;&#34;&#34;
    import numpy as np

    EPS = np.finfo(&#34;float&#34;).eps
    dyn_range = int(dyn_range)
    hop = int(hop)

    # Compute Mask
    w = np.hanning(framelen + 2)[1:-1]

    xl_frames = np.array(
        [w * xl[i : i + framelen] for i in range(0, len(xl) - framelen, hop)]
    )
    xr_frames = np.array(
        [w * xr[i : i + framelen] for i in range(0, len(xr) - framelen, hop)]
    )
    yl_frames = np.array(
        [w * yl[i : i + framelen] for i in range(0, len(yl) - framelen, hop)]
    )
    yr_frames = np.array(
        [w * yr[i : i + framelen] for i in range(0, len(yr) - framelen, hop)]
    )

    # Compute energies in dB
    xl_energies = 20 * np.log10(np.linalg.norm(xl_frames, axis=1) + EPS)
    xr_energies = 20 * np.log10(np.linalg.norm(xr_frames, axis=1) + EPS)

    # Find boolean mask of energies lower than dynamic_range dB
    # with respect to maximum clean speech energy frame
    maskxl = (np.max(xl_energies) - dyn_range - xl_energies) &lt; 0
    maskxr = (np.max(xr_energies) - dyn_range - xr_energies) &lt; 0

    mask = (maskxl == True) | (maskxr == True)

    # Remove silent frames by masking
    xl_frames = xl_frames[mask]
    xr_frames = xr_frames[mask]
    yl_frames = yl_frames[mask]
    yr_frames = yr_frames[mask]

    # init zero arrays to hold x, y with silent frames removed
    n_sil = (len(xl_frames) - 1) * hop + framelen
    xl_sil = np.zeros(n_sil)
    xr_sil = np.zeros(n_sil)
    yl_sil = np.zeros(n_sil)
    yr_sil = np.zeros(n_sil)

    for i in range(xl_frames.shape[0]):
        xl_sil[range(i * hop, i * hop + framelen)] += xl_frames[i, :]
        xr_sil[range(i * hop, i * hop + framelen)] += xr_frames[i, :]
        yl_sil[range(i * hop, i * hop + framelen)] += yl_frames[i, :]
        yr_sil[range(i * hop, i * hop + framelen)] += yr_frames[i, :]

    return xl_sil, xr_sil, yl_sil, yr_sil</code></pre>
</details>
</dd>
<dt id="MBSTOI.sosfilter"><code class="name flex">
<span>def <span class="ident">sosfilter</span></span>(<span>freq, freq_d, freq_u, fs, order, factor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/ecplus.py#L379-L394" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sosfilter(freq, freq_d, freq_u, fs, order, factor):
    sos = [[[]] for i in range(len(freq))]
    # Calculate coefficients per frequency band
    for idx, (lower, upper) in enumerate(zip(freq_d, freq_u)):
        # Downsample
        newfs = fs / factor[idx]  # New sampling rate
        # Create Butterworth Filter with SOS coefficients
        sos[idx] = signal.butter(
            N=order,
            Wn=np.array([lower, upper]) / (newfs / 2),
            btype=&#34;bandpass&#34;,
            analog=False,
            output=&#34;sos&#34;,
        )

    return sos</code></pre>
</details>
</dd>
<dt id="MBSTOI.stft"><code class="name flex">
<span>def <span class="ident">stft</span></span>(<span>x, win_size, fft_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Short-time Fourier transform based on MBSTOI MATLAB code.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>input signal</dd>
<dt><strong><code>win_size</code></strong> :&ensp;<code>int</code></dt>
<dd>N, the size of the window and the signal frames</dd>
<dt><strong><code>fft_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Nfft, the size of the fft in samples (zero-padding or not)</dd>
</dl>
<p>Returns
ndarray: 2D complex array, the short-time Fourier transform of x.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/stft.py#L1-L26" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def stft(x, win_size, fft_size):
    &#34;&#34;&#34;Short-time Fourier transform based on MBSTOI MATLAB code.

    Args:
        x (ndarray): input signal
        win_size (int): N, the size of the window and the signal frames
        fft_size (int): Nfft, the size of the fft in samples (zero-padding or not)

    Returns
        ndarray: 2D complex array, the short-time Fourier transform of x.

    &#34;&#34;&#34;
    import numpy as np

    hop = int(win_size / 2)
    frames = list(range(0, len(x) - win_size, hop))
    stft_out = np.zeros((len(frames), fft_size), dtype=np.complex128)

    w = np.hanning(win_size + 2)[1:-1]
    x = x.flatten()

    for i in range(len(frames)):
        ii = list(range(frames[i], (frames[i] + win_size), 1))
        stft_out[i, :] = np.fft.fft(x[ii] * w, n=fft_size, axis=0)

    return stft_out</code></pre>
</details>
</dd>
<dt id="MBSTOI.thirdoct"><code class="name flex">
<span>def <span class="ident">thirdoct</span></span>(<span>fs, nfft, num_bands, min_freq)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the 1/3 octave band matrix and its center frequencies
Based on mpariente/pystoi</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fs</code></strong> :&ensp;<code>int</code></dt>
<dd>sampling rate</dd>
<dt><strong><code>nfft</code></strong> :&ensp;<code>int</code></dt>
<dd>FFT size</dd>
<dt><strong><code>num_bands</code></strong> :&ensp;<code>int</code></dt>
<dd>number of one-third octave bands</dd>
<dt><strong><code>min_freq</code></strong> :&ensp;<code>int</code></dt>
<dd>center frequency of the lowest one-third octave band</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>obm (ndarray): octave band matrix
cf (ndarray): center frequencies
fids (ndarray): indices of frequency band edges</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/claritychallenge/clarity/blob/3c39139bc3999b80cb47168d043a2fc76224c6a0/projects/MBSTOI/MBSTOI/thirdoct.py#L1-L42" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def thirdoct(fs, nfft, num_bands, min_freq):
    &#34;&#34;&#34;Returns the 1/3 octave band matrix and its center frequencies
    Based on mpariente/pystoi

    Args:
        fs (int): sampling rate
        nfft (int): FFT size
        num_bands (int): number of one-third octave bands
        min_freq (int): center frequency of the lowest one-third octave band

    Returns:
        obm (ndarray): octave band matrix
        cf (ndarray): center frequencies
        fids (ndarray): indices of frequency band edges

    &#34;&#34;&#34;
    import numpy as np

    f = np.linspace(0, fs, nfft + 1)
    f = f[: int(nfft / 2) + 1]
    k = np.array(range(num_bands)).astype(float)
    cf = np.power(2.0 ** (1.0 / 3), k) * min_freq
    freq_low = min_freq * np.power(2.0, (2 * k - 1) / 6)
    freq_high = min_freq * np.power(2.0, (2 * k + 1) / 6)
    obm = np.zeros((num_bands, len(f)))  # a verifier
    fids = np.zeros((num_bands, 2))

    for i in range(len(cf)):
        # Match 1/3 oct band freq with fft frequency bin
        f_bin = np.argmin(np.square(f - freq_low[i]))
        freq_low[i] = f[f_bin]
        fl_ii = f_bin
        f_bin = np.argmin(np.square(f - freq_high[i]))
        freq_high[i] = f[f_bin]
        fh_ii = f_bin
        # Assign to the octave band matrix
        obm[i, fl_ii:fh_ii] = 1
        fids[i, :] = [fl_ii + 1, fh_ii]

    cf = cf[np.newaxis, :]

    return obm, cf, fids</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="http://claritychallenge.org">
<img height="150" src="http://claritychallenge.org/wp-content/uploads/2020/04/cropped-earfinal_clarity_custom_logo.png" alt="clarity">
</a>
</header>
<div class="gcse-search" style="height: 70px"
data-as_oq="site:claritychallenge.org inurl:github.com/claritychallenge"
data-gaCategoryParameter="MBSTOI">
</div>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MBSTOI.dsfactor" href="#MBSTOI.dsfactor">dsfactor</a></code></li>
<li><code><a title="MBSTOI.ec" href="#MBSTOI.ec">ec</a></code></li>
<li><code><a title="MBSTOI.ecplus" href="#MBSTOI.ecplus">ecplus</a></code></li>
<li><code><a title="MBSTOI.get_itds_ilds" href="#MBSTOI.get_itds_ilds">get_itds_ilds</a></code></li>
<li><code><a title="MBSTOI.mbstoi" href="#MBSTOI.mbstoi">mbstoi</a></code></li>
<li><code><a title="MBSTOI.mbstoi_noEC" href="#MBSTOI.mbstoi_noEC">mbstoi_noEC</a></code></li>
<li><code><a title="MBSTOI.mbstoiplus" href="#MBSTOI.mbstoiplus">mbstoiplus</a></code></li>
<li><code><a title="MBSTOI.mparametricild" href="#MBSTOI.mparametricild">mparametricild</a></code></li>
<li><code><a title="MBSTOI.remove_silent_frames" href="#MBSTOI.remove_silent_frames">remove_silent_frames</a></code></li>
<li><code><a title="MBSTOI.sosfilter" href="#MBSTOI.sosfilter">sosfilter</a></code></li>
<li><code><a title="MBSTOI.stft" href="#MBSTOI.stft">stft</a></code></li>
<li><code><a title="MBSTOI.thirdoct" href="#MBSTOI.thirdoct">thirdoct</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p><span style="color:#ddd">&#21328;</span></p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>